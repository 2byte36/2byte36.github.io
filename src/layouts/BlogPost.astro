---
import type { CollectionEntry } from "astro:content";
import FormattedDate from "@/components/Date.astro";
import Layout from "@/layouts/Layout.astro";

type Props = CollectionEntry<"blog">["data"] & {
  headings: { depth: number; slug: string; text: string }[];
};

const { title, pubDate, updatedDate, heroImage, headings = [] } = Astro.props;
---

<Layout>
  <article class="pb-10 w-full">
    <!-- Hero Image -->
    <div class="w-full grid place-items-center my-10 px-4 md:px-10 overflow-x-hidden">
      {
        heroImage && (
          <div class="w-full max-w-6xl bg-black rounded-2xl overflow-hidden shadow-2xl" style="aspect-ratio: 3349 / 1200;">
            <img 
              src={heroImage} 
              alt="hero-image" 
              class="w-full h-full object-contain object-center" 
            />
          </div>
        )
      }
    </div>

    <!-- Main Content with TOC Sidebar -->
    <div class="max-w-7xl mx-auto px-4 md:px-8 relative">
      <div class="lg:flex lg:gap-8 lg:items-start">
        
        <!-- Main Content Area -->
        <div class="lg:flex-1 min-w-0">
          <!-- Header -->
          <div class="mb-8">
            <div class="text-white/60 text-sm mb-2">
              <FormattedDate date={pubDate} />
              {
                updatedDate && (
                  <span class="ml-4">
                    Updated: <FormattedDate date={updatedDate} />
                  </span>
                )
              }
            </div>
            <h1 class="text-4xl md:text-5xl font-bold text-white mb-4">{title}</h1>
            <hr class="border-white/20" />
          </div>

          <!-- Article Content -->
          <div
            class="prose prose-lg prose-invert prose-headings:text-white prose-headings:font-bold prose-h2:text-3xl prose-h2:mt-12 prose-h2:mb-4 prose-h3:text-2xl prose-h3:mt-8 prose-h3:mb-3 prose-p:text-white/80 prose-p:leading-relaxed prose-a:text-blue-400 prose-a:no-underline hover:prose-a:underline prose-strong:text-white prose-code:text-green-400 prose-code:bg-white/5 prose-code:px-1 prose-code:py-0.5 prose-code:rounded prose-pre:bg-white/5 prose-pre:border prose-pre:border-white/10 prose-img:rounded-xl prose-img:shadow-lg prose-blockquote:border-l-4 prose-blockquote:border-white/20 prose-blockquote:text-white/70 prose-hr:border-white/10 max-w-none"
          >
            <slot />
          </div>
        </div>

        <!-- Mobile TOC Button -->
        <button 
          id="mobile-toc-btn"
          class="lg:hidden fixed bottom-6 right-6 z-50 bg-black/80 backdrop-blur-sm border border-white/20 hover:border-white/40 text-white/80 hover:text-white p-3 rounded-lg shadow-xl transition-all duration-200 flex items-center justify-center"
          aria-label="Toggle Table of Contents"
        >
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7"></path>
          </svg>
        </button>

        <!-- Mobile TOC Modal -->
        <div 
          id="mobile-toc-modal"
          class="lg:hidden fixed inset-0 z-40 hidden"
        >
          <!-- Overlay -->
          <div class="absolute inset-0 bg-black/70 backdrop-blur-sm" id="mobile-toc-overlay"></div>
          
          <!-- Modal Content -->
          <div class="absolute right-4 top-28 bottom-4 w-full max-w-xs bg-black/95 backdrop-blur-md border border-white/10 rounded-2xl shadow-2xl transform transition-transform duration-300 translate-x-full" id="mobile-toc-content">
            <div class="h-full flex flex-col">
              <!-- Header -->
              <div class="flex items-center justify-between px-6 py-4 border-b border-white/10">
                <h3 class="text-white font-semibold text-base">Table of Contents</h3>
                <button 
                  id="mobile-toc-close"
                  class="text-white/60 hover:text-white transition-colors p-1 -mr-1"
                  aria-label="Close"
                >
                  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                  </svg>
                </button>
              </div>
              
              <!-- TOC Content for Mobile -->
              <nav class="flex-1 overflow-y-auto px-6 py-5 scrollbar-thin">
                <nav class="toc mobile-toc">
                  <ul class="space-y-1 text-sm">
                    {(() => {
                      interface TocNode {
                        heading: any;
                        children: TocNode[];
                      }
                      
                      const buildNestedToc = (headings: any[]): TocNode[] => {
                        const stack: TocNode[] = [];
                        const root: TocNode[] = [];
                        
                        headings.forEach(heading => {
                          const node: TocNode = { heading, children: [] };
                          
                          while (stack.length > 0 && stack[stack.length - 1].heading.depth >= heading.depth) {
                            stack.pop();
                          }
                          
                          if (stack.length === 0) {
                            root.push(node);
                          } else {
                            stack[stack.length - 1].children.push(node);
                          }
                          
                          stack.push(node);
                        });
                        
                        return root;
                      };
                      
                      const tocTree = buildNestedToc(headings);
                      let itemCounter = 1000;
                      
                      const renderNode = (node: TocNode, level = 0): any => {
                        const hasChildren = node.children.length > 0;
                        const itemId = `toc-item-mobile-${itemCounter++}`;
                        
                        return (
                          <li class="mb-1">
                            <div class="flex items-start gap-1">
                              {hasChildren ? (
                                <button 
                                  class="toc-collapse-btn mt-1.5 text-white/40 hover:text-white transition-colors flex-shrink-0"
                                  data-target={itemId}
                                >
                                  <svg class="w-3 h-3 transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                  </svg>
                                </button>
                              ) : (
                                <span class="w-4 flex-shrink-0"></span>
                              )}
                              <a 
                                href={`#${node.heading.slug}`}
                                class={`mobile-toc-link hover:text-white transition-all duration-200 block py-1 flex-1 ${
                                  level === 0 ? 'text-white/60 text-sm' : 'text-white/50 text-xs'
                                }`}
                              >
                                {node.heading.text}
                              </a>
                            </div>
                            
                            {hasChildren && (
                              <ul id={itemId} class="toc-section ml-5 space-y-1 mt-1 overflow-hidden transition-all duration-200">
                                {node.children.map(child => renderNode(child, level + 1))}
                              </ul>
                            )}
                          </li>
                        );
                      };
                      
                      return tocTree.map(node => renderNode(node));
                    })()}
                  </ul>
                </nav>
              </nav>
            </div>
          </div>
        </div>

        <!-- Table of Contents Sidebar (Desktop Only) -->
        <div class="hidden lg:block lg:w-64 lg:flex-shrink-0">
          <div id="toc-wrapper">
            <nav class="border border-white/10 rounded-lg bg-white/5 backdrop-blur-sm p-3 max-h-[calc(100vh-10rem)] overflow-y-auto scrollbar-thin">
              <h3 class="text-white font-semibold text-sm mb-3 uppercase tracking-wider">On this page</h3>
              
              <!-- TOC Content with Nested Collapsible -->
              <nav class="toc">
                <ul class="space-y-1 text-sm">
                  {(() => {
                    // Simple grouping by parent-child relationship
                    interface TocNode {
                      heading: any;
                      children: TocNode[];
                    }
                    
                    const buildNestedToc = (headings: any[]): TocNode[] => {
                      const stack: TocNode[] = [];
                      const root: TocNode[] = [];
                      
                      headings.forEach(heading => {
                        const node: TocNode = { heading, children: [] };
                        
                        // Find parent in stack
                        while (stack.length > 0 && stack[stack.length - 1].heading.depth >= heading.depth) {
                          stack.pop();
                        }
                        
                        if (stack.length === 0) {
                          root.push(node);
                        } else {
                          stack[stack.length - 1].children.push(node);
                        }
                        
                        stack.push(node);
                      });
                      
                      return root;
                    };
                    
                    const tocTree = buildNestedToc(headings);
                    let itemCounter = 0;
                    
                    const renderNode = (node: TocNode, level = 0): any => {
                      const hasChildren = node.children.length > 0;
                      const itemId = `toc-item-${itemCounter++}`;
                      
                      return (
                        <li class="mb-1">
                          <div class="flex items-start gap-1">
                            {hasChildren ? (
                              <button 
                                class="toc-collapse-btn mt-1.5 text-white/40 hover:text-white transition-colors flex-shrink-0"
                                data-target={itemId}
                              >
                                <svg class="w-3 h-3 transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                              </button>
                            ) : (
                              <span class="w-4 flex-shrink-0"></span>
                            )}
                            <a 
                              href={`#${node.heading.slug}`}
                              class={`hover:text-white transition-all duration-200 block py-1 flex-1 ${
                                level === 0 ? 'text-white/60 text-sm' : 'text-white/50 text-xs'
                              }`}
                            >
                              {node.heading.text}
                            </a>
                          </div>
                          
                          {hasChildren && (
                            <ul id={itemId} class="toc-section ml-5 space-y-1 mt-1 overflow-hidden transition-all duration-200">
                              {node.children.map(child => renderNode(child, level + 1))}
                            </ul>
                          )}
                        </li>
                      );
                    };
                    
                    return tocTree.map(node => renderNode(node));
                  })()}
                </ul>
              </div>
            </nav>
          </div>
        </div>

      </div>
    </div>
  </article>
</Layout>

<style>
  /* Smooth scroll */
  html {
    scroll-behavior: smooth;
    scroll-padding-top: 100px;
  }
  
  #toc-wrapper {
    transition: none;
    z-index: 100;
  }

  /* Active TOC highlight */
  .toc a.active {
    @apply text-white font-semibold;
  }
  
  .toc a.active span {
    @apply text-white;
  }

  /* Custom scrollbar for TOC */
  .scrollbar-thin::-webkit-scrollbar {
    width: 4px;
  }
  
  .scrollbar-thin::-webkit-scrollbar-track {
    background: transparent;
  }
  
  .scrollbar-thin::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 2px;
  }
  
  .scrollbar-thin::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.3);
  }
  
  /* TOC Section collapsed state */
  .toc-section.collapsed {
    max-height: 0 !important;
    margin-top: 0 !important;
  }
</style>

<script>
  // Manual sticky implementation
  let tocWrapper: HTMLElement | null = null;
  let tocContainer: HTMLElement | null = null;
  let initialTop = 0;
  let containerLeft = 0;
  let containerWidth = 0;

  function updateTocPosition() {
    if (!tocWrapper || !tocContainer) return;
    
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const headerHeight = 96; // 6rem = 96px
    
    if (scrollTop > initialTop - headerHeight) {
      tocWrapper.style.position = 'fixed';
      tocWrapper.style.top = headerHeight + 'px';
      tocWrapper.style.left = containerLeft + 'px';
      tocWrapper.style.width = containerWidth + 'px';
    } else {
      tocWrapper.style.position = 'relative';
      tocWrapper.style.top = '0';
      tocWrapper.style.left = '0';
      tocWrapper.style.width = '100%';
    }
  }

  function initStickyToc() {
    tocWrapper = document.getElementById('toc-wrapper');
    if (!tocWrapper) return;
    
    tocContainer = tocWrapper.parentElement;
    if (!tocContainer) return;
    
    const rect = tocWrapper.getBoundingClientRect();
    initialTop = window.pageYOffset + rect.top;
    containerLeft = rect.left;
    containerWidth = rect.width;
    
    window.addEventListener('scroll', updateTocPosition);
    window.addEventListener('resize', () => {
      const rect = tocWrapper!.getBoundingClientRect();
      containerLeft = rect.left;
      containerWidth = rect.width;
      updateTocPosition();
    });
    
    updateTocPosition();
  }

  // Initialize on page load and navigation
  document.addEventListener('DOMContentLoaded', initStickyToc);
  document.addEventListener('astro:page-load', initStickyToc);

  // TOC Collapsible Sections
  function initCollapsibleToc() {
    const collapseButtons = document.querySelectorAll('.toc-collapse-btn');
    
    collapseButtons.forEach(btn => {
      const targetId = btn.getAttribute('data-target');
      const section = document.getElementById(targetId!);
      const svg = btn.querySelector('svg');
      
      if (section && svg) {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          const isCollapsed = section.classList.contains('collapsed');
          
          if (isCollapsed) {
            section.classList.remove('collapsed');
            section.style.maxHeight = section.scrollHeight + 'px';
            svg.style.transform = 'rotate(0deg)';
          } else {
            section.classList.add('collapsed');
            section.style.maxHeight = '0';
            svg.style.transform = 'rotate(-90deg)';
          }
        });
      }
    });
  }
  
  document.addEventListener('DOMContentLoaded', initCollapsibleToc);
  document.addEventListener('astro:page-load', initCollapsibleToc);

  // TOC active state on scroll
  function initTocActiveState() {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          const id = entry.target.getAttribute('id');
          const tocLink = document.querySelector(`.toc a[href="#${id}"]`);
          
          if (entry.isIntersecting && tocLink) {
            document.querySelectorAll('.toc a').forEach((link) => {
              link.classList.remove('active');
            });
            tocLink.classList.add('active');
          }
        });
      },
      { rootMargin: '-100px 0px -80% 0px' }
    );

    document.querySelectorAll('h2, h3, h4, h5, h6').forEach((heading) => {
      observer.observe(heading);
    });
  }
  
  document.addEventListener('DOMContentLoaded', initTocActiveState);
  document.addEventListener('astro:page-load', initTocActiveState);

  // Mobile TOC Toggle
  function initMobileToc() {
    const btn = document.getElementById('mobile-toc-btn');
    const modal = document.getElementById('mobile-toc-modal');
    const overlay = document.getElementById('mobile-toc-overlay');
    const closeBtn = document.getElementById('mobile-toc-close');
    const content = document.getElementById('mobile-toc-content');
    const tocLinks = document.querySelectorAll('.mobile-toc-link');

    if (!btn || !modal || !overlay || !closeBtn || !content) return;

    function openToc() {
      // Only work on mobile (screens smaller than 1024px)
      if (window.innerWidth >= 1024) return;
      
      modal.classList.remove('hidden');
      // Trigger reflow
      modal.offsetHeight;
      content.classList.remove('translate-x-full');
      document.body.style.overflow = 'hidden';
    }

    function closeToc() {
      content.classList.add('translate-x-full');
      setTimeout(() => {
        modal.classList.add('hidden');
        document.body.style.overflow = '';
      }, 300);
    }

    function toggleToc() {
      if (modal.classList.contains('hidden')) {
        openToc();
      } else {
        closeToc();
      }
    }

    btn.addEventListener('click', toggleToc);
    closeBtn.addEventListener('click', closeToc);
    overlay.addEventListener('click', closeToc);
    
    // Close TOC when clicking a link
    tocLinks.forEach(link => {
      link.addEventListener('click', () => {
        closeToc();
      });
    });

    // Close on escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
        closeToc();
      }
    });

    // Close TOC when resizing to desktop
    window.addEventListener('resize', () => {
      if (window.innerWidth >= 1024 && !modal.classList.contains('hidden')) {
        closeToc();
      }
    });
  }

  document.addEventListener('DOMContentLoaded', initMobileToc);
  document.addEventListener('astro:page-load', initMobileToc);
</script>
